import{TokenType as e,NumberType as t,tokenizer as r}from"@csstools/css-tokenizer";import{isWhitespaceNode as n,isCommentNode as o,isTokenNode as s,parseCommaSeparatedListOfComponentValues as i,isFunctionNode as a}from"@csstools/css-parser-algorithms";import u from"browserslist";import c from"https";import l from"path";const f=[e.Ident,e.Number,e.Percentage,e.Dimension],d=["<",">","="];function parseIfCondition(t){const r=t.value.filter((e=>!n(e)&&!o(e)));if(r.length>3)return!1;const i=r[0],a=r[1],u=r[2];if(!i||!a||!u)return!1;if(!s(i)||!s(a)||!s(u))return!1;const c=i.value,l=a.value,h=u.value;return l[0]===e.Delim&&(!!d.includes(l[4].value)&&(!!f.includes(c[0])&&(!!f.includes(h[0])&&{a:c,b:h,operator:l[4].value})))}function parseNotCondition(e){const t=parseIfCondition(e);return!!t&&{a:t.a,b:t.b,operator:t.operator}}function matchIfCondition(t){const r=t.a,n=t.b;if(r[0]===n[0]&&(r[0]!==e.Dimension||n[0]!==e.Dimension||r[4].unit.toLowerCase()===n[4].unit.toLowerCase())){switch(t.operator){case"<":if(r[4].value>=n[4].value)return`Died because A (${r[1]}) is no longer less than B (${n[1]})`;break;case">":if(r[4].value<=n[4].value)return`Died because A (${r[1]}) is no longer greater than B (${n[1]})`;break;case"=":if(r[4].value!==n[4].value)return`Died because A (${r[1]}) is no longer equal to B (${n[1]})`}return!0}}function matchNotCondition(t){const r=t.a,n=t.b;if(r[0]===n[0]&&(r[0]!==e.Dimension||n[0]!==e.Dimension||r[4].unit.toLowerCase()===n[4].unit.toLowerCase())){switch(t.operator){case"<":if(r[4].value<n[4].value)return`Died because A (${r[1]}) is less than B (${n[1]})`;break;case">":if(r[4].value>n[4].value)return`Died because A (${r[1]}) is greater than B (${n[1]})`;break;case"=":if(r[4].value===n[4].value)return`Died because A (${r[1]}) equals B (${n[1]})`}return!0}}function parseBrowserslistCondition(t){const r=t.value.filter((e=>!n(e)&&!o(e)));if(r.length>1)return!1;const i=r[0];if(!i)return!1;if(!s(i))return!1;const a=i.value;return a[0]===e.String&&a[4].value}function matchBrowserslistCondition(e,t){const r=u(e);for(let e=0;e<r.length;e++){const n=r[e];if(t.has(n))return!0}return`Died because the browsers matching "${e}" do not have any overlap with your project browserslist`}function died(e){return"string"==typeof e}function parseBeforeDateCondition(r){const i=r.value.filter((e=>!n(e)&&!o(e)));if(i.length>3)return!1;const a=i[0],u=i[1],c=i[2];if(!a||!u||!c)return!1;if(!s(a)||!s(u)||!s(c))return!1;const l=a.value,f=u.value,d=c.value;return l[0]===e.Number&&l[4].type===t.Integer&&(f[0]===e.Number&&f[4].type===t.Integer&&(d[0]===e.Number&&d[4].type===t.Integer&&{year:l[4].value,month:f[4].value,day:d[4].value}))}function matchBeforeDateCondition(e,t,r){const n=new Date;n.setUTCFullYear(e),n.setUTCMonth(t),n.setUTCDate(r);return(new Date).getTime()<n.getTime()||`Died because ${e}-${t}-${r} is in the past`}function parseIssueOpenCondition(r){const i=r.value.filter((e=>!n(e)&&!o(e)));if(i.length>2)return!1;const a=i[0],u=i[1];if(!a||!u)return!1;if(!s(a)||!s(u))return!1;const c=a.value,l=u.value;return c[0]===e.String&&(l[0]===e.Number&&l[4].type===t.Integer&&{repository:c[4].value,issue:l[4].value})}async function matchIssueOpenCondition(e,t,r){const n=`github-issue-open:${e}:${t}`;let o;if(!r.has(n))try{o=await fetch(e,t)}catch(e){return}return"closed"===o?(r.set(n,o),`Died because issue ${t} in ${e} was closed`):"open"===o?(r.set(n,o),!0):void 0}function fetch(e,t){return new Promise(((r,n)=>{let o=!1;const s=new URL(l.join("repos",e,"issues",t.toString()),"https://api.github.com/"),i={headers:{"User-Agent":"PostCSS TODO or Die"},timeout:15e3};process.env.GITHUB_TOKEN&&(i.headers.Authorization=`Bearer ${process.env.GITHUB_TOKEN}`);const a=c.request(s,i,(e=>{if(o)return;if(200!==e.statusCode)return o=!0,void n(new Error("Failed to fetch issue status"));let t="";e.on("data",(e=>{o||(t+=e.toString())})),e.on("end",(()=>{if(!o)try{const e=JSON.parse(t);return void r(e.state)}catch(e){return o=!0,void n(e)}}))}));a.on("timeout",(()=>{a.destroy()})),a.on("error",(e=>{o||(o=!0,n(e))})),a.end()}))}const creator=()=>{const e=new Set(u()),t=new Map;return{postcssPlugin:"postcss-todo-or-die",async Once(s,{result:u}){const c=[];s.walkAtRules((e=>{if("todo-or-die"===e.name.toLowerCase()){if(!e.params.trim())throw e.error("Rule must have valid params");c.push(e)}}));for(const s of c){const errorHandler=e=>{throw s.error(e.message)},c=r({css:s.params},{onParseError:errorHandler}),l=[];for(;!c.endOfFile();)l.push(c.nextToken());l.push(c.nextToken());const f=i(l,{onParseError:errorHandler});if(!f.length)return void s.warn(u,"Rule must have some valid params.");for(let r=0;r<f.length;r++){const i=f[r].filter((e=>!n(e)&&!o(e)));if(1!==i.length)return void s.warn(u,"Conditions must be split by commas when adding multiple in a list.");if(!a(i[0]))return void s.warn(u,"Conditions must be one of the supported functions.");switch(i[0].name[4].value.toLowerCase()){case"if":{const e=parseIfCondition(i[0]);if(!e)return void s.warn(u,"Incorrect arguments in `if()` function.");const t=matchIfCondition(e);if(died(t))throw s.error(t);break}case"not":{const e=parseNotCondition(i[0]);if(!e)return void s.warn(u,"Incorrect arguments in `not()` function.");const t=matchNotCondition(e);if(died(t))throw s.error(t);break}case"browserslist":{const t=parseBrowserslistCondition(i[0]);if(!t)return void s.warn(u,"Incorrect arguments in `browserslist()` function.");const r=matchBrowserslistCondition(t,e);if(died(r))throw s.error(r);break}case"before-date":{const e=parseBeforeDateCondition(i[0]);if(!e)return void s.warn(u,"Incorrect arguments in `before-date()` function.");const t=matchBeforeDateCondition(e.year,e.month,e.day);if(died(t))throw s.error(t);break}case"issue-open":{const e=parseIssueOpenCondition(i[0]);if(!e)return void s.warn(u,"Incorrect arguments in `issue-open()` function.");const r=await matchIssueOpenCondition(e.repository,e.issue,t);if(died(r))throw s.error(r);break}}}s.nodes&&s.nodes.length?s.replaceWith(s.nodes):s.remove()}}}};creator.postcss=!0;export{creator as default};
