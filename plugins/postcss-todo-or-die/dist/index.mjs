import{TokenType as e,NumberType as t,tokenizer as r}from"@csstools/css-tokenizer";import{isWhitespaceNode as n,isCommentNode as o,isTokenNode as i,parseCommaSeparatedListOfComponentValues as s,isFunctionNode as a}from"@csstools/css-parser-algorithms";import u from"browserslist";const c=[e.Ident,e.Number,e.Percentage,e.Dimension],l=["<",">","="];function parseIfCondition(t){const r=t.value.filter((e=>!n(e)&&!o(e)));if(r.length>3)return!1;const s=r[0],a=r[1],u=r[2];if(!s||!a||!u)return!1;if(!i(s)||!i(a)||!i(u))return!1;const f=s.value,d=a.value,m=u.value;return d[0]===e.Delim&&(!!l.includes(d[4].value)&&(!!c.includes(f[0])&&(!!c.includes(m[0])&&{a:f,b:m,operator:d[4].value})))}function parseNotCondition(e){const t=parseIfCondition(e);return!!t&&{a:t.a,b:t.b,operator:t.operator}}function matchIfCondition(t){const r=t.a,n=t.b;if(r[0]===n[0]&&(r[0]!==e.Dimension||n[0]!==e.Dimension||r[4].unit.toLowerCase()===n[4].unit.toLowerCase())){switch(t.operator){case"<":if(r[4].value>=n[4].value)return`Died because A (${r[1]}) is no longer less than B (${n[1]})`;break;case">":if(r[4].value<=n[4].value)return`Died because A (${r[1]}) is no longer greater than B (${n[1]})`;break;case"=":if(r[4].value!==n[4].value)return`Died because A (${r[1]}) is no longer equal to B (${n[1]})`}return!0}}function matchNotCondition(t){const r=t.a,n=t.b;if(r[0]===n[0]&&(r[0]!==e.Dimension||n[0]!==e.Dimension||r[4].unit.toLowerCase()===n[4].unit.toLowerCase())){switch(t.operator){case"<":if(r[4].value<n[4].value)return`Died because A (${r[1]}) is less than B (${n[1]})`;break;case">":if(r[4].value>n[4].value)return`Died because A (${r[1]}) is greater than B (${n[1]})`;break;case"=":if(r[4].value===n[4].value)return`Died because A (${r[1]}) equals B (${n[1]})`}return!0}}function parseBrowserslistCondition(t){const r=t.value.filter((e=>!n(e)&&!o(e)));if(r.length>1)return!1;const s=r[0];if(!s)return!1;if(!i(s))return!1;const a=s.value;return a[0]===e.String&&a[4].value}function matchBrowserslistCondition(e,t){const r=u(e);for(let e=0;e<r.length;e++){const n=r[e];if(t.has(n))return!0}return`Died because the browsers matching "${e}" do not have any overlap with your project browserslist`}function died(e){return"string"==typeof e}function parseBeforeDateCondition(r){const s=r.value.filter((e=>!n(e)&&!o(e)));if(s.length>3)return!1;const a=s[0],u=s[1],c=s[2];if(!a||!u||!c)return!1;if(!i(a)||!i(u)||!i(c))return!1;const l=a.value,f=u.value,d=c.value;return l[0]===e.Number&&l[4].type===t.Integer&&(f[0]===e.Number&&f[4].type===t.Integer&&(d[0]===e.Number&&d[4].type===t.Integer&&{year:l[4].value,month:f[4].value,day:d[4].value}))}function matchBeforeDateCondition(e,t,r){const n=new Date;n.setUTCFullYear(e),n.setUTCMonth(t),n.setUTCDate(r);return(new Date).getTime()<n.getTime()||`Died because ${e}-${t}-${r} is in the past`}const creator=()=>{const e=new Set(u());return{postcssPlugin:"postcss-todo-or-die",Once(t,{result:i}){t.walkAtRules((t=>{if("todo-or-die"!==t.name.toLowerCase())return;if(!t.params.trim())throw t.error("Rule must have valid params");const errorHandler=e=>{throw t.error(e.message)},u=r({css:t.params},{onParseError:errorHandler}),c=[];for(;!u.endOfFile();)c.push(u.nextToken());c.push(u.nextToken());const l=s(c,{onParseError:errorHandler});if(l.length){for(let r=0;r<l.length;r++){const s=l[r].filter((e=>!n(e)&&!o(e)));if(1!==s.length)return void t.warn(i,"Conditions must be split by commas when adding multiple in a list.");if(!a(s[0]))return void t.warn(i,"Conditions must be one of the supported functions.");switch(s[0].name[4].value.toLowerCase()){case"if":{const e=parseIfCondition(s[0]);if(!e)return void t.warn(i,"Incorrect arguments in `if()` function.");const r=matchIfCondition(e);if(died(r))throw t.error(r);break}case"not":{const e=parseNotCondition(s[0]);if(!e)return void t.warn(i,"Incorrect arguments in `not()` function.");const r=matchNotCondition(e);if(died(r))throw t.error(r);break}case"browserslist":{const r=parseBrowserslistCondition(s[0]);if(!r)return void t.warn(i,"Incorrect arguments in `browserslist()` function.");const n=matchBrowserslistCondition(r,e);if(died(n))throw t.error(n);break}case"before-date":{const e=parseBeforeDateCondition(s[0]);if(!e)return void t.warn(i,"Incorrect arguments in `before-date()` function.");const r=matchBeforeDateCondition(e.year,e.month,e.day);if(died(r))throw t.error(r);break}}}t.nodes&&t.nodes.length?t.replaceWith(t.nodes):t.remove()}else t.warn(i,"Rule must have some valid params.")}))}}};creator.postcss=!0;export{creator as default};
