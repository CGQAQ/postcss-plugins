function hasKeyframesAtRuleAncestor(t){let e=t.parent;for(;e;)if("atrule"===e.type){if("keyframes"===t.parent.name.toLowerCase())return!0;e=e.parent}else e=e.parent;return!1}function cloneDeclaration(t,e,o){return t.cloneBefore({value:e,prop:o})}function transformSide(t,e){return o=>{cloneDeclaration(o,o.value,`${t}-${e}`)}}var t;!function(t){t.TopToBottom="top-to-bottom",t.BottomToTop="bottom-to-top",t.RightToLeft="right-to-left",t.LeftToRight="left-to-right"}(t||(t={}));const e=["top","right","bottom","left"],creator=o=>{const n=Object.assign({preserve:!1,blockDirection:t.TopToBottom,inlineDirection:t.LeftToRight},o),i=Object.values(t);if(!i.includes(n.blockDirection))throw new Error(`[postcss-logical] "blockDirection" must be one of ${i.join(", ")}`);if(!i.includes(n.inlineDirection))throw new Error(`[postcss-logical] "inlineDirection" must be one of ${i.join(", ")}`);const[r,a]=n.blockDirection.split("-to-"),[s,c]=n.inlineDirection.split("-to-");if(!e.every((t=>[r,a,s,c].includes(t))))throw new Error('[postcss-logical] "blockDirection" and "inlineDirection" must be on separate axes');const makeTransform=t=>e=>{if(hasKeyframesAtRuleAncestor(e))return;const o=e.parent;t(e),n.preserve||e.remove(),o.nodes.length||o.remove()};return{postcssPlugin:"postcss-logical",Declaration:{"margin-block-start":makeTransform(transformSide("margin",r)),"margin-block-end":makeTransform(transformSide("margin",a)),"margin-inline-start":makeTransform(transformSide("margin",s)),"margin-inline-end":makeTransform(transformSide("margin",c)),"padding-block-start":makeTransform(transformSide("padding",r)),"padding-block-end":makeTransform(transformSide("padding",a)),"padding-inline-start":makeTransform(transformSide("padding",s)),"padding-inline-end":makeTransform(transformSide("padding",c))}}};creator.postcss=!0;export{creator as default};
